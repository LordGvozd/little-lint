import ast
from dataclasses import dataclass
from typing import TypeAlias, Callable

from src.models import Violation

FileRule: TypeAlias = Callable[[str], list[Violation] | None]
LineRule: TypeAlias = Callable[[str], Violation | None]
AstRule: TypeAlias = Callable[[ast.AST], list[Violation] | None]


@dataclass
class AstChecker:
    rule: AstRule

    ignore_comments: bool = False


AnyAstType: TypeAlias = (
    type[ast.AST]
    | type[ast.mod]
    | type[ast.Module]
    | type[ast.Interactive]
    | type[ast.Expression]
    | type[ast.FunctionType]
    | type[ast.Suite]
    | type[ast.stmt]
    | type[ast.FunctionDef]
    | type[ast.AsyncFunctionDef]
    | type[ast.ClassDef]
    | type[ast.Return]
    | type[ast.Delete]
    | type[ast.Assign]
    | type[ast.TypeAlias]
    | type[ast.AugAssign]
    | type[ast.AnnAssign]
    | type[ast.For]
    | type[ast.AsyncFor]
    | type[ast.While]
    | type[ast.If]
    | type[ast.With]
    | type[ast.AsyncWith]
    | type[ast.Match]
    | type[ast.Raise]
    | type[ast.Try]
    | type[ast.TryStar]
    | type[ast.Assert]
    | type[ast.Import]
    | type[ast.ImportFrom]
    | type[ast.Global]
    | type[ast.Nonlocal]
    | type[ast.Expr]
    | type[ast.Pass]
    | type[ast.Break]
    | type[ast.Continue]
    | type[ast.expr]
    | type[ast.BoolOp]
    | type[ast.NamedExpr]
    | type[ast.BinOp]
    | type[ast.UnaryOp]
    | type[ast.Lambda]
    | type[ast.IfExp]
    | type[ast.Dict]
    | type[ast.Set]
    | type[ast.ListComp]
    | type[ast.SetComp]
    | type[ast.DictComp]
    | type[ast.GeneratorExp]
    | type[ast.Await]
    | type[ast.Yield]
    | type[ast.YieldFrom]
    | type[ast.Compare]
    | type[ast.Call]
    | type[ast.FormattedValue]
    | type[ast.JoinedStr]
    | type[ast.Constant]
    | type[ast.Attribute]
    | type[ast.Subscript]
    | type[ast.Starred]
    | type[ast.Name]
    | type[ast.List]
    | type[ast.Tuple]
    | type[ast.Slice]
    | type[ast.expr_context]
    | type[ast.Load]
    | type[ast.Store]
    | type[ast.Del]
    | type[ast.AugLoad]
    | type[ast.AugStore]
    | type[ast.Param]
    | type[ast.boolop]
    | type[ast.And]
    | type[ast.Or]
    | type[ast.operator]
    | type[ast.Add]
    | type[ast.Sub]
    | type[ast.Mult]
    | type[ast.MatMult]
    | type[ast.Div]
    | type[ast.Mod]
    | type[ast.Pow]
    | type[ast.LShift]
    | type[ast.RShift]
    | type[ast.BitOr]
    | type[ast.BitXor]
    | type[ast.BitAnd]
    | type[ast.FloorDiv]
    | type[ast.unaryop]
    | type[ast.Invert]
    | type[ast.Not]
    | type[ast.UAdd]
    | type[ast.USub]
    | type[ast.cmpop]
    | type[ast.Eq]
    | type[ast.NotEq]
    | type[ast.Lt]
    | type[ast.LtE]
    | type[ast.Gt]
    | type[ast.GtE]
    | type[ast.Is]
    | type[ast.IsNot]
    | type[ast.In]
    | type[ast.NotIn]
    | type[ast.comprehension]
    | type[ast.excepthandler]
    | type[ast.ExceptHandler]
    | type[ast.arguments]
    | type[ast.arg]
    | type[ast.keyword]
    | type[ast.alias]
    | type[ast.withitem]
    | type[ast.match_case]
    | type[ast.pattern]
    | type[ast.MatchValue]
    | type[ast.MatchSingleton]
    | type[ast.MatchSequence]
    | type[ast.MatchMapping]
    | type[ast.MatchClass]
    | type[ast.MatchStar]
    | type[ast.MatchAs]
    | type[ast.MatchOr]
    | type[ast.type_ignore]
    | type[ast.TypeIgnore]
    | type[ast.type_param]
    | type[ast.TypeVar]
    | type[ast.ParamSpec]
    | type[ast.TypeVarTuple]
    | type[ast.slice]
    | type[ast.Index]
    | type[ast.ExtSlice]
)
